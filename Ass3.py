# -*- coding: utf-8 -*-
"""Untitled83.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ipL9fYK3tPUeZpmM5iVzx8esphvRmYfq
"""

pip install memory-profiler matplotlib numpy

import time
import numpy as np
import matplotlib.pyplot as plt
from memory_profiler import memory_usage

# Binary Search function
def binary_search(arr, target):
    def recursive_search(low, high):
        if low > high:
            return -1
        mid = (low + high) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            return recursive_search(mid + 1, high)
        else:
            return recursive_search(low, mid - 1)
    return recursive_search(0, len(arr) - 1)

# Strassen's Matrix Multiplication function
def strassen_multiply(A, B):
    if len(A) == 1:
        return A * B
    n = len(A)
    mid = n // 2
    A11, A12, A21, A22 = A[:mid, :mid], A[:mid, mid:], A[mid:, :mid], A[mid:, mid:]
    B11, B12, B21, B22 = B[:mid, :mid], B[:mid, mid:], B[mid:, :mid], B[mid:, mid:]
    M1 = strassen_multiply(A11 + A22, B11 + B22)
    M2 = strassen_multiply(A21 + A22, B11)
    M3 = strassen_multiply(A11, B12 - B22)
    M4 = strassen_multiply(A22, B21 - B11)
    M5 = strassen_multiply(A11 + A12, B22)
    M6 = strassen_multiply(A21 - A11, B11 + B12)
    M7 = strassen_multiply(A12 - A22, B21 + B22)
    C11 = M1 + M4 - M5 + M7
    C12 = M3 + M5
    C21 = M2 + M4
    C22 = M1 - M2 + M3 + M6
    C = np.vstack((np.hstack((C11, C12)), np.hstack((C21, C22))))
    return C

# Testing and plotting results
def test_binary_search():
    sizes = [10**i for i in range(1, 7)]  # Array sizes from 10 to 1,000,000
    times = []
    mem_usages = []
    for size in sizes:
        arr = list(range(size))  # Sorted array for Binary Search
        target = size - 1  # Target is the largest element
        start_time = time.time()
        mem_usage = memory_usage((binary_search, (arr, target)), max_usage=True)
        times.append(time.time() - start_time)
        mem_usages.append(mem_usage)
    return sizes, times, mem_usages

def test_strassen_multiplication():
    sizes = [2**i for i in range(1, 7)]  # Matrix sizes (2x2 to 64x64)
    times = []
    mem_usages = []
    for size in sizes:
        A = np.random.rand(size, size)
        B = np.random.rand(size, size)
        start_time = time.time()
        mem_usage = memory_usage((strassen_multiply, (A, B)), max_usage=True)
        times.append(time.time() - start_time)
        mem_usages.append(mem_usage)
    return sizes, times, mem_usages

# Run tests and gather results
bs_sizes, bs_times, bs_memory = test_binary_search()
sm_sizes, sm_times, sm_memory = test_strassen_multiplication()

# Plotting results
plt.figure(figsize=(12, 6))

# Plot for Execution Time
plt.subplot(1, 2, 1)
plt.plot(bs_sizes, bs_times, label="Binary Search", marker='o')
plt.plot(sm_sizes, sm_times, label="Strassen's Multiplication", marker='s')
plt.xscale('log')
plt.yscale('log')
plt.xlabel("Input Size")
plt.ylabel("Execution Time (seconds)")
plt.title("Execution Time Comparison")
plt.legend()

# Plot for Memory Usage
plt.subplot(1, 2, 2)
plt.plot(bs_sizes, bs_memory, label="Binary Search", marker='o')
plt.plot(sm_sizes, sm_memory, label="Strassen's Multiplication", marker='s')
plt.xscale('log')
plt.yscale('log')
plt.xlabel("Input Size")
plt.ylabel("Memory Usage (MB)")
plt.title("Memory Usage Comparison")
plt.legend()

plt.tight_layout()
plt.show()